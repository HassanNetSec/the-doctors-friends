import os
from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel, EmailStr
from pymongo import MongoClient
from passlib.context import CryptContext # For password hashing
from jose import jwt, JWTError # For token creation and validation
from typing import Optional, Dict
import secrets
from bson import ObjectId # Used to convert MongoDB's _id to string if needed
from Helper.encryptionAndDecryption import encrypt_password,verifypassword
from fastapi.middleware.cors import CORSMiddleware
# Initialize FastAPI app
app = FastAPI(title="Doctor Friend Patient API")
# ----------------------------------------------------
# üåü ADD THIS CORS MIDDLEWARE SECTION üåü
# ----------------------------------------------------

origins = [
    # Add the URL of your frontend application here!
    # e.g., if your frontend runs on http://localhost:3000
    "http://localhost:3000", 
    "http://127.0.0.1:3000",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,              # Specifies which origins are allowed to access the API
    allow_credentials=True,             # Allows cookies/authorization headers to be included
    allow_methods=["*"],                # Allows all standard methods (GET, POST, OPTIONS, etc.)
    allow_headers=["*"],                # Allows all standard headers, especially 'Content-Type'
)
# --- 1. CONFIGURATION AND INITIALIZATION ---

# Retrieve MongoDB connection string (NOTE: Store in environment variables for production)
MONGO_URI = "mongodb+srv://hassandevolper123:zY24sZAroO8UvJrG@mongodbtest.a354d.mongodb.net/?appName=MongoDbTest"
DB_NAME = "user_credentials"
COLLECTION_NAME = "login_details"



# Initialize MongoDB client and select database/collection
client = MongoClient(MONGO_URI)
db = client[DB_NAME]
users_collection = db[COLLECTION_NAME]

# Initialize password hashing context
# This is a critical security component!
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# --- 2. Pydantic Models for Data Validation ---

class UserSchema(BaseModel):
    """Schema for user data stored in the database."""
    # We use Optional[str] for _id as it's generated by Mongo, not required for input
    id: Optional[str] = None 
    name: str
    email: EmailStr
    phone: str
    hashed_password: str

    class Config:
        # Allows Pydantic to work with MongoDB's _id field
        populate_by_name = True
        json_encoders = {ObjectId: str}
        arbitrary_types_allowed = True


class UserCreate(BaseModel):
    """Input model for user registration."""
    name: str
    email: EmailStr
    phone: str
    password: str

class UserLogin(BaseModel):
    """Input model for user login."""
    email: EmailStr
    password: str

# --- 3. Utility Functions ---

def hash_password(password: str) -> str:
    """Hashes the plain-text password using bcrypt."""
    encrypted_password = encrypt_password(password)
    if encrypted_password is None:
        raise ValueError("Password hashing failed")
    return encrypted_password  # ‚úÖ Return the result, not the function

def verify_password(plain_password: str, hashed_password: bytes) -> bool:
    """Verifies a plain-text password against the stored hash."""
    return verifypassword(plain_password,hashed_password)

# --- 4. API Endpoints ---

## üìù User Registration
@app.post("/register_user")
def register_user(user: UserCreate):
    """
    Registers a new user by checking for an existing email, 
    hashing the password, and storing the record in MongoDB.
    """
    
    # 1. Check if user already exists
    if users_collection.find_one({"email": user.email}):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered."
        )

    # 2. Hash the password securely
    hashed_pass = hash_password(user.password)

    # 3. Create the document to insert
    user_doc = {
        'name': user.name,
        'email': user.email,
        'phone': user.phone,
        'hashed_password': hashed_pass # Store the hash, NOT the plain password
    }

    # 4. Insert the user into the database
    try:
        # Use the global users_collection, not db.users_collection
        result = users_collection.insert_one(user_doc)
    except Exception as e:
        # Log the error (not shown here) and raise a 500
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Database insertion failed: {e}"
        )

    # 5. Return success response
    return {
        'status': status.HTTP_200_OK,
        'message': 'User registered successfully!',
        'user_id': str(result.inserted_id) # Convert ObjectId to string
    }

@app.post("/login")
def loginUser(user:UserLogin):
    payload = {
        'email' : user.email,
        'password' : user.password
    }

    userDoc = users_collection.find_one({'email' : payload['email']})

    if userDoc:
        # get password of this user
        hashPswd = userDoc.get('hashed_password')

        if verify_password(payload['password'],hashPswd):
            return({
                'status' : 200,
                'message' : "sucessfully login"
            })
        else:
            raise HTTPException(status_code=404,detail='incorrect password')
    else:
        raise HTTPException(status_code=404,detail="incorrect email")


